{"version":3,"sources":["webpack:///./codecs/hqx/pkg/squooshhqx_bg.js","webpack:///./src/codecs/hqx/processor.ts"],"names":["cachegetUint32Memory0","getUint32Memory0","buffer","squooshhqx_bg","Uint32Array","WASM_VECTOR_LEN","cachegetInt32Memory0","getInt32Memory0","Int32Array","resize","input_image","input_width","input_height","factor","ptr0","arg","malloc","ptr","length","set","passArray32ToWasm0","len0","r0","r1","v1","len","subarray","getArrayU32FromWasm0","slice","async","hqx","data","opts","input","result","width","height","ImageData","Uint8ClampedArray","__webpack_require__","d","__webpack_exports__"],"mappings":"yEAEA,IAAIA,EAAwB,KAC5B,SAASC,IAIL,OAH8B,OAA1BD,GAAkCA,EAAsBE,SAAWC,EAAA,EAAYD,SAC/EF,EAAwB,IAAII,YAAYD,EAAA,EAAYD,SAEjDF,EAGX,IAAIK,EAAkB,EAStB,IAAIC,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBJ,SAAWC,EAAA,EAAYD,SAC7EI,EAAuB,IAAIE,WAAWL,EAAA,EAAYD,SAE/CI,EAaJ,SAASG,EAAOC,EAAaC,EAAaC,EAAcC,GAC3D,IAAIC,EA1BR,SAA4BC,EAAKC,GAC7B,MAAMC,EAAMD,EAAoB,EAAbD,EAAIG,QAGvB,OAFAjB,IAAmBkB,IAAIJ,EAAKE,EAAM,GAClCZ,EAAkBU,EAAIG,OACfD,EAsBIG,CAAmBV,EAAaP,EAAA,GACvCkB,EAAOhB,EACXF,EAAA,EAAY,EAAGW,EAAMO,EAAMV,EAAaC,EAAcC,GACtD,IAAIS,EAAKf,IAAkB,GACvBgB,EAAKhB,IAAkB,GACvBiB,EAhBR,SAA8BP,EAAKQ,GAC/B,OAAOxB,IAAmByB,SAAST,EAAM,EAAGA,EAAM,EAAIQ,GAe7CE,CAAqBL,EAAIC,GAAIK,QAEtC,OADAzB,EAAA,EAAqBmB,EAAS,EAALC,GAClBC,EC1CJK,eAAeC,EACpBC,EACAC,GAEA,MAAMC,EAAQF,EACRG,EAASzB,EACb,IAAIL,YAAY6B,EAAMF,KAAK7B,QAC3B+B,EAAME,MACNF,EAAMG,OACNJ,EAAKnB,QAEP,OAAO,IAAIwB,UACT,IAAIC,kBAAkBJ,EAAOhC,QAC7B6B,EAAKI,MAAQH,EAAKnB,OAClBkB,EAAKK,OAASJ,EAAKnB,QAjBvB0B,EAAAC,EAAAC,EAAA,wBAAAX,K","file":"process-hqx.ba022.worker.js","sourcesContent":["import * as wasm from './squooshhqx_bg.wasm';\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {Uint32Array} input_image\n* @param {number} input_width\n* @param {number} input_height\n* @param {number} factor\n* @returns {Uint32Array}\n*/\nexport function resize(input_image, input_width, input_height, factor) {\n    var ptr0 = passArray32ToWasm0(input_image, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.resize(8, ptr0, len0, input_width, input_height, factor);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayU32FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 4);\n    return v1;\n}\n\n","import { resize } from '../../../codecs/hqx/pkg';\nimport { HqxOptions } from './processor-meta';\n\nexport async function hqx(\n  data: ImageData,\n  opts: HqxOptions,\n): Promise<ImageData> {\n  const input = data;\n  const result = resize(\n    new Uint32Array(input.data.buffer),\n    input.width,\n    input.height,\n    opts.factor,\n  );\n  return new ImageData(\n    new Uint8ClampedArray(result.buffer),\n    data.width * opts.factor,\n    data.height * opts.factor,\n  );\n}\n"],"sourceRoot":""}