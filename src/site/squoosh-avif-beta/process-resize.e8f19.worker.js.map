{"version":3,"sources":["webpack:///./codecs/resize/pkg/squoosh_resize_bg.js","webpack:///./src/codecs/resize/processor.ts","webpack:///./src/codecs/resize/util.ts"],"names":["cachegetUint8Memory0","getUint8Memory0","buffer","squoosh_resize_bg","Uint8Array","WASM_VECTOR_LEN","cachegetInt32Memory0","getInt32Memory0","Int32Array","resize","input_image","input_width","input_height","output_width","output_height","typ_idx","premultiply","color_space_conversion","ptr0","arg","malloc","ptr","length","set","passArray8ToWasm0","len0","r0","r1","v1","len","subarray","getArrayU8FromWasm0","slice","__webpack_require__","d","__webpack_exports__","processor_resize","resizeMethods","async","data","opts","input","fitMethod","sx","sy","sw","sh","dw","dh","endAspect","newSh","newSw","getContainOffsets","width","height","inputPixels","Uint32Array","y","start","copyWithin","ImageData","Uint8ClampedArray","crop","Math","round","result","indexOf","method","linearRGB"],"mappings":"yEAEA,IAAIA,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBE,SAAWC,EAAA,EAAYD,SAC7EF,EAAuB,IAAII,WAAWD,EAAA,EAAYD,SAE/CF,EAGX,IAAIK,EAAkB,EAStB,IAAIC,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBJ,SAAWC,EAAA,EAAYD,SAC7EI,EAAuB,IAAIE,WAAWL,EAAA,EAAYD,SAE/CI,EAiBJ,SAASG,EAAOC,EAAaC,EAAaC,EAAcC,EAAcC,EAAeC,EAASC,EAAaC,GAC9G,IAAIC,EA9BR,SAA2BC,EAAKC,GAC5B,MAAMC,EAAMD,EAAoB,EAAbD,EAAIG,QAGvB,OAFArB,IAAkBsB,IAAIJ,EAAKE,EAAM,GACjChB,EAAkBc,EAAIG,OACfD,EA0BIG,CAAkBd,EAAaP,EAAA,GACtCsB,EAAOpB,EACXF,EAAA,EAAY,EAAGe,EAAMO,EAAMd,EAAaC,EAAcC,EAAcC,EAAeC,EAASC,EAAaC,GACzG,IAAIS,EAAKnB,IAAkB,GACvBoB,EAAKpB,IAAkB,GACvBqB,EApBR,SAA6BP,EAAKQ,GAC9B,OAAO5B,IAAkB6B,SAAST,EAAM,EAAGA,EAAM,EAAIQ,GAmB5CE,CAAoBL,EAAIC,GAAIK,QAErC,OADA7B,EAAA,EAAqBuB,EAAS,EAALC,GAClBC,EChDXK,EAAAC,EAAAC,EAAA,2BAAAC,IAmBA,MAAMC,EAAiD,CACrD,WAAY,SAAU,WAAY,YAG7BC,eAAeF,EAAOG,EAAiBC,GAC5C,IAAIC,EAAQF,EAEZ,GAAuB,YAAnBC,EAAKE,UAAyB,CAChC,MAAMC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GC5BjB,SAA2BD,EAAYC,EAAYC,EAAYC,GACpE,MACMC,EAAYF,EAAKC,EAEvB,GAAIC,EAHkBJ,EAAKC,EAGI,CAC7B,MAAMI,EAAQL,EAAKI,EAEnB,MAAO,CAAEJ,KAAIC,GAAII,EAAOP,GAAI,EAAGC,IADhBE,EAAKI,GAAS,GAI/B,MAAMC,EAAQL,EAAKG,EAEnB,MAAO,CAAEH,KAAID,GAAIM,EAAOR,IADTE,EAAKM,GAAS,EACMP,GAAI,GDgBVQ,CAAkBb,EAAKc,MAAOd,EAAKe,OAAQd,EAAKa,MAAOb,EAAKc,QACvFb,EAzBJ,SAAcF,EAAiBI,EAAYC,EAAYC,EAAYC,GACjE,MAAMS,EAAc,IAAIC,YAAYjB,EAAKA,KAAKrC,QAG9C,IAAK,IAAIuD,EAAI,EAAGA,EAAIX,EAAIW,GAAK,EAAG,CAC9B,MAAMC,GAAUD,EAAIb,GAAML,EAAKc,MAASV,EACxCY,EAAYI,WAAWF,EAAIZ,EAAIa,EAAOA,EAAQb,GAGhD,OAAO,IAAIe,UACT,IAAIC,kBAAkBN,EAAYrD,OAAO8B,MAAM,EAAGa,EAAKC,EAAK,IAC5DD,EAAIC,GAcIgB,CAAKrB,EAAOsB,KAAKC,MAAMrB,GAAKoB,KAAKC,MAAMpB,GAAKmB,KAAKC,MAAMnB,GAAKkB,KAAKC,MAAMlB,IAGjF,MAAMmB,EAASxD,EACb,IAAIL,WAAWqC,EAAMF,KAAKrC,QAASuC,EAAMY,MAAOZ,EAAMa,OAAQd,EAAKa,MAAOb,EAAKc,OAC/EjB,EAAc6B,QAAQ1B,EAAK2B,QAAS3B,EAAKxB,YAAawB,EAAK4B,WAG7D,OAAO,IAAIR,UAAU,IAAIC,kBAAkBI,EAAO/D,QAASsC,EAAKa,MAAOb,EAAKc,U","file":"process-resize.e8f19.worker.js","sourcesContent":["import * as wasm from './squoosh_resize_bg.wasm';\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @param {Uint8Array} input_image\n* @param {number} input_width\n* @param {number} input_height\n* @param {number} output_width\n* @param {number} output_height\n* @param {number} typ_idx\n* @param {boolean} premultiply\n* @param {boolean} color_space_conversion\n* @returns {Uint8Array}\n*/\nexport function resize(input_image, input_width, input_height, output_width, output_height, typ_idx, premultiply, color_space_conversion) {\n    var ptr0 = passArray8ToWasm0(input_image, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.resize(8, ptr0, len0, input_width, input_height, output_width, output_height, typ_idx, premultiply, color_space_conversion);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    var v1 = getArrayU8FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 1);\n    return v1;\n}\n\n","import { WorkerResizeOptions } from './processor-meta';\nimport { getContainOffsets } from './util';\nimport { resize as codecResize } from '../../../codecs/resize/pkg';\n\nfunction crop(data: ImageData, sx: number, sy: number, sw: number, sh: number): ImageData {\n  const inputPixels = new Uint32Array(data.data.buffer);\n\n  // Copy within the same buffer for speed and memory efficiency.\n  for (let y = 0; y < sh; y += 1) {\n    const start = ((y + sy) * data.width) + sx;\n    inputPixels.copyWithin(y * sw, start, start + sw);\n  }\n\n  return new ImageData(\n    new Uint8ClampedArray(inputPixels.buffer.slice(0, sw * sh * 4)),\n    sw, sh,\n  );\n}\n\n/** Resize methods by index */\nconst resizeMethods: WorkerResizeOptions['method'][] = [\n  'triangle', 'catrom', 'mitchell', 'lanczos3',\n];\n\nexport async function resize(data: ImageData, opts: WorkerResizeOptions): Promise<ImageData> {\n  let input = data;\n\n  if (opts.fitMethod === 'contain') {\n    const { sx, sy, sw, sh } = getContainOffsets(data.width, data.height, opts.width, opts.height);\n    input = crop(input, Math.round(sx), Math.round(sy), Math.round(sw), Math.round(sh));\n  }\n\n  const result = codecResize(\n    new Uint8Array(input.data.buffer), input.width, input.height, opts.width, opts.height,\n    resizeMethods.indexOf(opts.method), opts.premultiply, opts.linearRGB,\n  );\n\n  return new ImageData(new Uint8ClampedArray(result.buffer), opts.width, opts.height);\n}\n","export function getContainOffsets(sw: number, sh: number, dw: number, dh: number) {\n  const currentAspect = sw / sh;\n  const endAspect = dw / dh;\n\n  if (endAspect > currentAspect) {\n    const newSh = sw / endAspect;\n    const newSy = (sh - newSh) / 2;\n    return { sw, sh: newSh, sx: 0, sy: newSy };\n  }\n\n  const newSw = sh * endAspect;\n  const newSx = (sw - newSw) / 2;\n  return { sh, sw: newSw, sx: newSx, sy: 0 };\n}\n"],"sourceRoot":""}